package SpecialAlgorithm

// 440. 字典序的第K小数字
// 给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。
/*
算法思路: 模拟字典序（十叉树前序遍历）+ 子树节点数计算
1. 想象数字 1 到 n 构成了一个十叉树（或前缀树）。
   - 根节点（虚拟）的孩子是 1, 2, ..., 9。
   - 节点 1 的孩子是 10, 11, ..., 19。
   - 节点 10 的孩子是 100, 101, ..., 109，以此类推。
2. 字典序就是这个十叉树的前序遍历（DFS）顺序。
3. 直接进行 DFS 遍历会超时（O(n) 可能达到 10^9）。我们需要一种更快的方式来定位第 k 个节点。
4. 核心方法：从当前节点 `curr` 出发，计算其所有子节点（包括自身）构成的子树中有多少个节点在 `[1, n]` 范围内。这个计算通过 `calSteps` 函数完成。
5. `calSteps(n1, n)` 函数：
   - 计算以 `n1` 为根的子树（包括`n1`自身）中有多少个节点 `<= n`。
   - 它逐层计算：
     - 当前层范围是 `[n1, n2)`，其中 `n2 = n1 + 1`。
     - 计算当前层在 `[1, n]` 范围内的节点数：`min(n + 1, n2) - n1`。
     - 累加到 `steps`。
     - 进入下一层：`n1 *= 10`, `n2 *= 10`。
     - 直到 `n1 > n`。
6. 主循环逻辑：
   - 初始化当前数字 `curr = 1`。
   - 将 `k` 减 1，因为我们要找的是第 k 个，而我们的逻辑是先看当前 `curr`，再决定跳过多少步。相当于把 `curr` 作为第 0 步消耗掉。
   - 循环直到 `k == 0`：
     a. 计算从 `curr` 开始的子树大小 `steps = calSteps(curr, n)`。
     b. **比较 `steps` 和 `k`**：
        - 如果 `steps <= k`：说明第 k 个数不在以 `curr` 为根的子树中。我们需要跳过这整个 `steps` 个数，然后移动到 `curr` 的下一个兄弟节点 (`curr + 1`)。更新 `k -= steps` 和 `curr++`。
        - 如果 `steps > k`：说明第 k 个数就在以 `curr` 为根的子树中。我们不能跳过这个子树。我们需要深入一层。
           - 首先，因为我们“进入”了 `curr` 这个节点（相当于 pre-order 访问了它），所以消耗掉 1 步，更新 `k--`。
           - 然后，移动到 `curr` 的第一个子节点，更新 `curr *= 10`。
7. 循环结束后，`curr` 就是字典序第 k 小的数字。
*/
func findKthNumber(n int, k int) int {
	curr := 1
	// 将 k 调整为 0-based index 来考虑跳过的步数
	// 我们相当于从 '1' 这个位置开始，要再走 k-1 步
	k--

	for k > 0 {
		// 计算以 curr 为根的子树（包括 curr）中有多少个节点 <= n
		steps := calSteps(curr, n)

		if steps <= k {
			// 第 k 个数不在 curr 的子树中
			// 跳过整个子树
			k -= steps
			// 移动到 curr 的下一个兄弟节点
			curr++
		} else {
			// 第 k 个数在 curr 的子树中
			// 不能跳过 curr，并且要进入下一层
			k-- // 消耗掉 curr 这个节点本身（相当于 pre-order 访问）
			// 移动到 curr 的第一个子节点
			curr *= 10
		}
	}
	// 当 k == 0 时，当前的 curr 就是目标数字
	return curr
}

// calSteps 计算以 n1 为根的子树中，所有 <= n 的节点的总数
func calSteps(n1 int, n int) int {
	steps := 0
	n2 := n1 + 1 // n1 的下一个兄弟节点，用于界定当前层的范围 [n1, n2)
	for n1 <= n {
		// 计算当前层 [n1, n2) 中有多少节点 <= n
		// min(n + 1, n2) 是为了处理 n 正好落在 [n1, n2) 区间内的情况
		// 如果 n >= n2，则这一层有 n2 - n1 个节点
		// 如果 n < n2，则这一层有 n - n1 + 1 个节点
		// 这两种情况合并为 min(n + 1, n2) - n1
		steps += min(n+1, n2) - n1

		// 检查下一层是否可能包含有效节点
		if n1 > n/10 { // 快速判断，防止溢出和不必要的计算
			break
		}
		// 移动到下一层
		n1 *= 10
		n2 *= 10
	}
	return steps
}
